diff --git a/3rdparty/libprocess/3rdparty/stout/include/stout/gzip.hpp b/3rdparty/libprocess/3rdparty/stout/include/stout/gzip.hpp
index ef36f1b..bc0d818 100644
--- a/3rdparty/libprocess/3rdparty/stout/include/stout/gzip.hpp
+++ b/3rdparty/libprocess/3rdparty/stout/include/stout/gzip.hpp
@@ -1,9 +1,7 @@
 #ifndef __STOUT_GZIP_HPP__
 #define __STOUT_GZIP_HPP__
 
-#ifdef HAVE_LIBZ
 #include <zlib.h>
-#endif
 
 #include <string>
 
@@ -26,15 +24,8 @@ namespace gzip {
 //   #define Z_DEFAULT_COMPRESSION  (-1)
 inline Try<std::string> compress(
     const std::string& decompressed,
-#ifdef HAVE_LIBZ
     int level = Z_DEFAULT_COMPRESSION)
-#else
-    int level = -1)
-#endif
 {
-#ifndef HAVE_LIBZ
-  return Error("libz is not available");
-#else
   // Verify the level is within range.
   if (!(level == Z_DEFAULT_COMPRESSION ||
       (level >= Z_NO_COMPRESSION && level <= Z_BEST_COMPRESSION))) {
@@ -88,16 +79,12 @@ inline Try<std::string> compress(
     return Error("Failed to clean up zlib: " + std::string(stream.msg));
   }
   return result;
-#endif // HAVE_LIBZ
 }
 
 
 // Returns a gzip decompressed version of the provided string.
 inline Try<std::string> decompress(const std::string& compressed)
 {
-#ifndef HAVE_LIBZ
-  return Error("libz is not available");
-#else
   z_stream_s stream;
   stream.next_in =
     const_cast<Bytef*>(reinterpret_cast<const Bytef*>(compressed.data()));
@@ -141,7 +128,6 @@ inline Try<std::string> decompress(const std::string& compressed)
     return Error("Failed to clean up zlib: " + std::string(stream.msg));
   }
   return result;
-#endif // HAVE_LIBZ
 }
 
 } // namespace gzip {
diff --git a/3rdparty/libprocess/3rdparty/stout/include/stout/net.hpp b/3rdparty/libprocess/3rdparty/stout/include/stout/net.hpp
index 1c5f88a..d03de5a 100644
--- a/3rdparty/libprocess/3rdparty/stout/include/stout/net.hpp
+++ b/3rdparty/libprocess/3rdparty/stout/include/stout/net.hpp
@@ -8,9 +8,7 @@
 #include <sys/socket.h>
 #include <sys/types.h>
 
-#ifdef HAVE_LIBCURL
 #include <curl/curl.h>
-#endif
 
 #include <string>
 
@@ -26,9 +24,6 @@ namespace net {
 // specified HTTP or FTP URL into a file at the specified path.
 inline Try<int> download(const std::string& url, const std::string& path)
 {
-#ifndef HAVE_LIBCURL
-  return Error("libcurl is not available");
-#else
   Try<int> fd = os::open(
       path, O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR | S_IRGRP | S_IRWXO);
 
@@ -70,7 +65,6 @@ inline Try<int> download(const std::string& url, const std::string& path)
   }
 
   return Try<int>::some(code);
-#endif // HAVE_LIBCURL
 }
 
 // Returns a Try of the hostname for the provided IP. If the hostname cannot
diff --git a/3rdparty/libprocess/3rdparty/stout/include/stout/nothing.hpp b/3rdparty/libprocess/3rdparty/stout/include/stout/nothing.hpp
index c11a010..d0f925d 100644
--- a/3rdparty/libprocess/3rdparty/stout/include/stout/nothing.hpp
+++ b/3rdparty/libprocess/3rdparty/stout/include/stout/nothing.hpp
@@ -1,6 +1,6 @@
-#ifndef __NOTHING_HPP__
-#define __NOTHING_HPP__
+#ifndef __STOUT_NOTHING_HPP__
+#define __STOUT_NOTHING_HPP__
 
 struct Nothing {};
 
-#endif // __NOTHING_HPP__
+#endif // __STOUT_NOTHING_HPP__
diff --git a/3rdparty/libprocess/3rdparty/stout/include/stout/preprocessor.hpp b/3rdparty/libprocess/3rdparty/stout/include/stout/preprocessor.hpp
index 466e16f..bd9c411 100644
--- a/3rdparty/libprocess/3rdparty/stout/include/stout/preprocessor.hpp
+++ b/3rdparty/libprocess/3rdparty/stout/include/stout/preprocessor.hpp
@@ -1,5 +1,5 @@
-#ifndef __PROCESS_PREPROCESSOR_HPP__
-#define __PROCESS_PREPROCESSOR_HPP__
+#ifndef __STOUT_PROCESS_PREPROCESSOR_HPP__
+#define __STOUT_PROCESS_PREPROCESSOR_HPP__
 
 #include <boost/preprocessor/cat.hpp>
 
@@ -26,4 +26,4 @@
 #define REPEAT BOOST_PP_REPEAT
 #define REPEAT_FROM_TO BOOST_PP_REPEAT_FROM_TO
 
-#endif // __PROCESS_PREPROCESSOR_HPP__
+#endif // __STOUT_PROCESS_PREPROCESSOR_HPP__
diff --git a/3rdparty/libprocess/3rdparty/stout/include/stout/proc.hpp b/3rdparty/libprocess/3rdparty/stout/include/stout/proc.hpp
index c3eac30..1bbbaa1 100644
--- a/3rdparty/libprocess/3rdparty/stout/include/stout/proc.hpp
+++ b/3rdparty/libprocess/3rdparty/stout/include/stout/proc.hpp
@@ -1,5 +1,23 @@
-#ifndef __PROC_HPP__
-#define __PROC_HPP__
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __STOUT_PROC_HPP__
+#define __STOUT_PROC_HPP__
 
 // This file contains linux-only utilities for /proc.
 #ifndef __linux__
@@ -472,4 +490,4 @@ inline Try<std::list<CPU> > cpus()
 
 } // namespace proc {
 
-#endif // __PROC_HPP__
+#endif // __STOUT_PROC_HPP__
diff --git a/3rdparty/libprocess/src/decoder.hpp b/3rdparty/libprocess/src/decoder.hpp
index 4c29229..be410d9 100644
--- a/3rdparty/libprocess/src/decoder.hpp
+++ b/3rdparty/libprocess/src/decoder.hpp
@@ -28,14 +28,17 @@ public:
     settings.on_message_begin = &DataDecoder::on_message_begin;
     settings.on_header_field = &DataDecoder::on_header_field;
     settings.on_header_value = &DataDecoder::on_header_value;
-    settings.on_path = &DataDecoder::on_path;
     settings.on_url = &DataDecoder::on_url;
-    settings.on_fragment = &DataDecoder::on_fragment;
-    settings.on_query_string = &DataDecoder::on_query_string;
     settings.on_body = &DataDecoder::on_body;
     settings.on_headers_complete = &DataDecoder::on_headers_complete;
     settings.on_message_complete = &DataDecoder::on_message_complete;
 
+#if !(HTTP_PARSER_VERSION_MAJOR >=2) 
+    settings.on_path = &DataDecoder::on_path;
+    settings.on_fragment = &DataDecoder::on_fragment;
+    settings.on_query_string = &DataDecoder::on_query_string;
+#endif    
+    
     http_parser_init(&parser, HTTP_REQUEST);
 
     parser.data = this;
@@ -163,19 +166,37 @@ private:
     return 0;
   }
 
-  static int on_path(http_parser* p, const char* data, size_t length)
+  static int on_url(http_parser* p, const char* data, size_t length)
   {
     DataDecoder* decoder = (DataDecoder*) p->data;
     assert(decoder->request != NULL);
-    decoder->request->path.append(data, length);
-    return 0;
+    decoder->request->url.append(data, length);
+    int ret = 0;
+    
+#if (HTTP_PARSER_VERSION_MAJOR >=2) 
+    // reworked parsing for version 2.0 &> 
+    http_parser_url tUrlData;
+    ret = http_parser_parse_url(data, length, 0, &tUrlData);
+     
+    if (tUrlData.field_set & (1<<UF_PATH))
+        decoder->request->path.append(data+tUrlData.field_data[UF_PATH].off, tUrlData.field_data[UF_PATH].len);
+    
+    if (tUrlData.field_set & (1<<UF_FRAGMENT))
+        decoder->request->fragment.append(data+tUrlData.field_data[UF_FRAGMENT].off, tUrlData.field_data[UF_FRAGMENT].len);
+    
+    if (tUrlData.field_set & (1<<UF_QUERY))
+        decoder->query.append(data+tUrlData.field_data[UF_QUERY].off, tUrlData.field_data[UF_QUERY].len);
+#endif
+    
+    return ret;
   }
 
-  static int on_url(http_parser* p, const char* data, size_t length)
-  {
+#if !(HTTP_PARSER_VERSION_MAJOR >=2) 
+  static int on_path(http_parser* p, const char* data, size_t length)
+  { 
     DataDecoder* decoder = (DataDecoder*) p->data;
     assert(decoder->request != NULL);
-    decoder->request->url.append(data, length);
+    decoder->request->path.append(data, length);
     return 0;
   }
 
@@ -194,6 +215,7 @@ private:
     decoder->request->fragment.append(data, length);
     return 0;
   }
+#endif
 
   static int on_body(http_parser* p, const char* data, size_t length)
   {
@@ -234,14 +256,17 @@ public:
     settings.on_message_begin = &ResponseDecoder::on_message_begin;
     settings.on_header_field = &ResponseDecoder::on_header_field;
     settings.on_header_value = &ResponseDecoder::on_header_value;
-    settings.on_path = &ResponseDecoder::on_path;
-    settings.on_url = &ResponseDecoder::on_url;
-    settings.on_fragment = &ResponseDecoder::on_fragment;
-    settings.on_query_string = &ResponseDecoder::on_query_string;
+    settings.on_url = &ResponseDecoder::on_url;    
     settings.on_body = &ResponseDecoder::on_body;
     settings.on_headers_complete = &ResponseDecoder::on_headers_complete;
     settings.on_message_complete = &ResponseDecoder::on_message_complete;
 
+#if !(HTTP_PARSER_VERSION_MAJOR >=2) 
+    settings.on_path = &ResponseDecoder::on_path;
+    settings.on_fragment = &ResponseDecoder::on_fragment;
+    settings.on_query_string = &ResponseDecoder::on_query_string;
+#endif
+    
     http_parser_init(&parser, HTTP_RESPONSE);
 
     parser.data = this;
diff --git a/Makefile.am b/Makefile.am
index 685bd68..11befd9 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -18,12 +18,14 @@ ACLOCAL_AMFLAGS = -I m4
 
 AUTOMAKE_OPTIONS = foreign
 
-SUBDIRS = . 3rdparty src ec2
+SUBDIRS = . include src ec2
 
 EXTRA_DIST =
 
 PHONY_TARGETS =
 
+pkgconfigdir = $(libdir)/pkgconfig
+pkgconfig_DATA = mesos.pc
 
 # Since we generate several files in src/ with config.status, make
 # sure they're regenerated before we recurse into the src directory.
diff --git a/bootstrap b/bootstrap
index ed0bc36..de6dc73 100755
--- a/bootstrap
+++ b/bootstrap
@@ -43,22 +43,21 @@ fi
 
 # Make sure that we have a version of automake that doesn't force
 # 'subdir-objects'.
-
-AUTOMAKE_VERSION="$($AUTOMAKE --version | head -1 | cut -d' ' -f4)"
-case ${AUTOMAKE_VERSION} in
-  1.14)
-    cat >&2 <<__EOF__
-
-Mesos requires automake < 1.14 due to incompatibility issues
-with the 'subdir-objects' option.
-
-See https://issues.apache.org/jira/browse/MESOS-577 and
-please downgrade your automake installation.
-
-__EOF__
-    exit 1
-  ;;
-esac
+#AUTOMAKE_VERSION=$(automake --version | head -1 | cut -d' ' -f4)
+#case ${AUTOMAKE_VERSION} in
+#  1.14)
+#    cat >&2 <<__EOF__
+#
+#Mesos requires automake < 1.14 due to incompatibility issues
+#with the 'subdir-objects' option.
+#
+#See https://issues.apache.org/jira/browse/MESOS-577 and
+#please downgrade your automake installation.
+#
+#__EOF__
+#    exit 1
+#  ;;
+#esac
 
 # Note that we don't use '--no-recursive' because older versions of
 # autoconf/autoreconf bail with that option. Unfortunately this means
diff --git a/configure.ac b/configure.ac
index ba4ec1d..ac164aa 100644
--- a/configure.ac
+++ b/configure.ac
@@ -74,12 +74,10 @@ ac_configure_args="$ac_configure_args_post"
 AC_CONFIG_COMMANDS_PRE([ac_configure_args="$ac_configure_args_pre"])
 AC_CONFIG_COMMANDS_POST([ac_configure_args="$ac_configure_args_post"])
 
-AC_CONFIG_SUBDIRS([3rdparty/libprocess])
-
-AC_CONFIG_FILES([Makefile])
+AC_CONFIG_FILES([Makefile mesos.pc])
 AC_CONFIG_FILES([ec2/Makefile])
 AC_CONFIG_FILES([src/Makefile])
-AC_CONFIG_FILES([3rdparty/Makefile])
+AC_CONFIG_FILES([include/Makefile])
 
 AC_CONFIG_FILES([bin/mesos.sh], [chmod +x bin/mesos.sh])
 AC_CONFIG_FILES([bin/mesos-local.sh], [chmod +x bin/mesos-local.sh])
@@ -131,20 +129,8 @@ AC_ARG_WITH([curl],
                            (and its dependencies) are available]),
              [], [with_curl=yes])
 
-AC_ARG_WITH([included-zookeeper],
-            AS_HELP_STRING([--without-included-zookeeper],
-                           [excludes building and using the included ZooKeeper
-                           package in lieu of a system installed version (note,
-                           however, that no attempt is made to find the package
-                           and explicitly setting CPPFLAGS and LDFLAGS as
-                           appropriate may be necessary)]),
-             [], [with_included_zookeeper=yes])
-
-# TODO(benh): Support --without-included-protobuf,
-# --without-included-glog, etc. Doing this for protobuf is
-# considerably more tricky because we need to make sure that 'protoc'
-# exists, that a protobuf JAR exists or we can make one, that a
-# protobuf egg exists or we can make one, etc.
+# External zookeeper required, may want to add additional positive check
+AC_CHECK_HEADERS([zookeeper/zookeeper.h], [], [AC_MSG_ERROR([zookeeper is missing])])
 
 AC_ARG_VAR([JAVA_HOME], [location of Java Development Kit (JDK)])
 
@@ -162,7 +148,7 @@ case "${target_os}" in
     echo Setting up build environment for ${target_cpu} ${target_os}
     echo ===========================================================
     OS_NAME=linux
-    LIBS="$LIBS -lrt"
+    #LIBS="$LIBS -lrt"
     ;;
   darwin*)
     echo ===========================================================
@@ -449,7 +435,10 @@ if test "x$enable_python" = "xyes"; then
   AC_SUBST([PYTHON]) # Used by the example shell scripts and src/Makefile.am.
 
   AC_DEFINE([MESOS_HAS_PYTHON])
-
+  
+  #Added check for boto module
+  AC_PYTHON_MODULE(boto, yes)
+  
   has_python=yes
 fi
 
@@ -466,8 +455,8 @@ fi
 
 
 # Check if we should/can build with libcurl.
-if test "x$with_curl" = "xyes"; then
-  AC_CHECK_LIB([z], [gzread], [],
+#if test "x$with_curl" = "xyes"; then
+  AC_CHECK_LIB([z], [gzread], [AC_MSG_RESULT([found])],
                [AC_MSG_ERROR([cannot find libz
   -------------------------------------------------------------------
   We need libz for libcurl; you can avoid this with --without-curl,
@@ -476,48 +465,79 @@ if test "x$with_curl" = "xyes"; then
   -------------------------------------------------------------------
   ])])
 
-  AC_CHECK_LIB([crypto], [BN_init], [],
-               [AC_MSG_ERROR([cannot find libcrypto
-  -------------------------------------------------------------------
-  We need libcrypto for libcurl; you can avoid this with
-  --without-curl, but it will mean executor and task resources cannot
-  be downloaded over http.
-  -------------------------------------------------------------------
-  ])])
-
-  AC_CHECK_LIB([ssl], [SSL_accept], [],
-               [AC_MSG_ERROR([cannot find libssl
-  -------------------------------------------------------------------
-  We need libssl for libcurl; you can avoid this with --without-curl,
-  but it will mean executor and task resources cannot be downloaded
-  over http.
-  -------------------------------------------------------------------
-  ])])
-
-  AC_CHECK_LIB([curl], [curl_global_init], [],
-               [AC_MSG_ERROR([cannot find libcurl
-  -------------------------------------------------------------------
-  You can avoid this with --without-curl, but it will mean executor
-  and task resources cannot be downloaded over http.
-  -------------------------------------------------------------------
-  ])])
-
-fi
-
-
-AM_CONDITIONAL([WITH_INCLUDED_ZOOKEEPER],
-               [test "x$with_included_zookeeper" = "xyes"])
-
+## NOTES: TSTCLAIR This linkage is unused. 
+
+  #AC_CHECK_LIB([crypto], [BN_init], [AC_MSG_RESULT([found])],
+  #             [AC_MSG_ERROR([cannot find libcrypto
+  #-------------------------------------------------------------------
+  #We need libcrypto for libcurl; you can avoid this with
+  #--without-curl, but it will mean executor and task resources cannot
+  #be downloaded overhttp.
+  #-------------------------------------------------------------------
+  #])])
+
+  #AC_CHECK_LIB([ssl], [SSL_accept], [AC_MSG_RESULT([found])],
+  #             [AC_MSG_ERROR([cannot find libssl
+  #-------------------------------------------------------------------
+  #We need libssl for libcurl; you can avoid this with --without-curl,
+  #but it will mean executor and task resources cannot be downloaded
+  #over http.
+  #-------------------------------------------------------------------
+  #])])
+
+  #AC_CHECK_LIB([curl], [curl_global_init], [AC_MSG_RESULT([found])],
+  #             [AC_MSG_ERROR([cannot find libcurl
+  #-------------------------------------------------------------------
+  #You can avoid this with --without-curl, but it will mean executor
+  #and task resources cannot be downloaded over http.
+  #-------------------------------------------------------------------
+  #])])
+#fi
+
+# Check for libev
+# rawhide has caused some issue
+# PKG_CHECK_MODULES([LIBEV], [libev], [], [AC_MSG_ERROR([libev library is missing])])
+
+# Check for leveldb - may want to be more elaborate
+AC_CHECK_HEADERS([leveldb/db.h], [], [AC_MSG_ERROR([leveldb is missing])])
+
+# Check for protobuf
+PKG_CHECK_MODULES([PROTOBUF], [protobuf], [], [AC_MSG_ERROR([protobuf library is missing])])
+
+# Check for protobuf - may want be more elaborate (compile check) or change --with
+AC_CHECK_HEADERS([google/protobuf/compiler/code_generator.h], [], [AC_MSG_ERROR([protobuf is missing])])
+
+# Check for boost
+AC_LANG_PUSH([C++])
+AC_CHECK_HEADERS([boost/foreach.hpp], [], [AC_MSG_ERROR(Boost libraries is missing)])
+AC_LANG_POP([C++])
+
+# Check for gtest
+AC_CHECK_HEADERS([gtest/gtest.h], [], [AC_MSG_ERROR([gtest library is missing])])
+
+# Check for glog
+PKG_CHECK_MODULES([GLOG], [libglog], [], [AC_MSG_ERROR([glog library is missing])])
+
+# Check for gmock
+AC_CHECK_FILE([/usr/src/gmock/gmock-all.cc], 
+              [AC_CONFIG_LINKS([src/gmock-all.cc:/usr/src/gmock/gmock-all.cc])], 
+              [AC_MSG_ERROR([gmock sources are missing])])
+
+AM_CONDITIONAL([HAS_GPERFTOOLS], [test "x$gperftools" = "xyes"])
+
+# Used for conditionally building source files (e.g., only want to
+# build stout/tests/proc_tests.cpp on Linux).
+AM_CONDITIONAL([OS_LINUX], [test "x$OS_NAME" = "xlinux"])
 
 # TODO(benh): Also check for md5 support so we can use the CRAM-MD5
 # mechanism. We can likely do a AC_CHECK_LIB looking for a particular
 # function only provided if md5 support is present.
-AC_CHECK_LIB([sasl2], [sasl_done], [],
-             [AC_MSG_ERROR([cannot find libsasl2
--------------------------------------------------------------------
-We need libsasl2 for authentication!
--------------------------------------------------------------------
-])])
+#AC_CHECK_LIB([sasl2], [sasl_done], [AC_MSG_RESULT([found])],
+#             [AC_MSG_ERROR([cannot find libsasl2
+#-------------------------------------------------------------------
+#We need libsasl2 for authentication!
+#-------------------------------------------------------------------
+#])])
 
 
 AC_OUTPUT
diff --git a/include/Makefile.am b/include/Makefile.am
new file mode 100644
index 0000000..a7fb991
--- /dev/null
+++ b/include/Makefile.am
@@ -0,0 +1,102 @@
+
+nobase_include_HEADERS = mesos/mesos.proto \
+mesos/resources.hpp \
+mesos/scheduler.hpp \
+mesos/mesos.hpp \
+mesos/process/gc.hpp \
+mesos/process/once.hpp \
+mesos/process/protobuf.hpp \
+mesos/process/gmock.hpp \
+mesos/process/io.hpp \
+mesos/process/clock.hpp \
+mesos/process/statistics.hpp \
+mesos/process/timeout.hpp \
+mesos/process/id.hpp \
+mesos/process/tuples/tuples.hpp \
+mesos/process/tuples/details.hpp \
+mesos/process/message.hpp \
+mesos/process/delay.hpp \
+mesos/process/collect.hpp \
+mesos/process/event.hpp \
+mesos/process/future.hpp \
+mesos/process/help.hpp \
+mesos/process/deferred.hpp \
+mesos/process/async.hpp \
+mesos/process/gtest.hpp \
+mesos/process/run.hpp \
+mesos/process/logging.hpp \
+mesos/process/dispatch.hpp \
+mesos/process/http.hpp \
+mesos/process/limiter.hpp \
+mesos/process/owned.hpp \
+mesos/process/pid.hpp \
+mesos/process/timer.hpp \
+mesos/process/process.hpp \
+mesos/process/socket.hpp \
+mesos/process/latch.hpp \
+mesos/process/shared.hpp \
+mesos/process/defer.hpp \
+mesos/process/executor.hpp \
+mesos/process/filter.hpp \
+mesos/process/profiler.hpp \
+mesos/process/mime.hpp \
+mesos/process/time.hpp \
+mesos/stout/gzip.hpp \
+mesos/stout/flags.hpp \
+mesos/stout/cache.hpp \
+mesos/stout/protobuf.hpp \
+mesos/stout/fs.hpp \
+mesos/stout/thread.hpp \
+mesos/stout/flags/flags.hpp \
+mesos/stout/flags/flag.hpp \
+mesos/stout/flags/parse.hpp \
+mesos/stout/flags/loader.hpp \
+mesos/stout/stopwatch.hpp \
+mesos/stout/error.hpp \
+mesos/stout/fatal.hpp \
+mesos/stout/exit.hpp \
+mesos/stout/hashset.hpp \
+mesos/stout/os.hpp \
+mesos/stout/nothing.hpp \
+mesos/stout/numify.hpp \
+mesos/stout/json.hpp \
+mesos/stout/linkedhashmap.hpp \
+mesos/stout/preprocessor.hpp \
+mesos/stout/try.hpp \
+mesos/stout/lambda.hpp \
+mesos/stout/utils.hpp \
+mesos/stout/result.hpp \
+mesos/stout/gtest.hpp \
+mesos/stout/set.hpp \
+mesos/stout/path.hpp \
+mesos/stout/hashmap.hpp \
+mesos/stout/foreach.hpp \
+mesos/stout/strings.hpp \
+mesos/stout/net.hpp \
+mesos/stout/multihashmap.hpp \
+mesos/stout/proc.hpp \
+mesos/stout/bytes.hpp \
+mesos/stout/os/signals.hpp \
+mesos/stout/os/killtree.hpp \
+mesos/stout/os/linux.hpp \
+mesos/stout/os/osx.hpp \
+mesos/stout/os/ls.hpp \
+mesos/stout/os/sendfile.hpp \
+mesos/stout/os/sysctl.hpp \
+mesos/stout/os/process.hpp \
+mesos/stout/os/pstree.hpp \
+mesos/stout/os/read.hpp \
+mesos/stout/os/exists.hpp \
+mesos/stout/os/fork.hpp \
+mesos/stout/option.hpp \
+mesos/stout/stringify.hpp \
+mesos/stout/none.hpp \
+mesos/stout/uuid.hpp \
+mesos/stout/some.hpp \
+mesos/stout/format.hpp \
+mesos/stout/multimap.hpp \
+mesos/stout/duration.hpp \
+mesos/stout/check.hpp \
+mesos/executor.hpp \
+mesos/values.hpp
+
diff --git a/m4/ac_python_module.m4 b/m4/ac_python_module.m4
new file mode 100644
index 0000000..32b9d72
--- /dev/null
+++ b/m4/ac_python_module.m4
@@ -0,0 +1,30 @@
+dnl @synopsis AC_PYTHON_MODULE(modname[, fatal])
+dnl
+dnl Checks for Python module.
+dnl
+dnl If fatal is non-empty then absence of a module will trigger an
+dnl error.
+dnl
+dnl @category InstalledPackages
+dnl @author Andrew Collier <colliera@nu.ac.za>.
+dnl @version 2004-07-14
+dnl @license AllPermissive
+
+AC_DEFUN([AC_PYTHON_MODULE],[
+	AC_MSG_CHECKING(python module: $1)
+	python -c "import $1" 2>/dev/null
+	if test $? -eq 0;
+	then
+		AC_MSG_RESULT(yes)
+		eval AS_TR_CPP(HAVE_PYMOD_$1)=yes
+	else
+		AC_MSG_RESULT(no)
+		eval AS_TR_CPP(HAVE_PYMOD_$1)=no
+		#
+		if test -n "$2"
+		then
+			AC_MSG_ERROR(failed to find required module $1)
+			exit 1
+		fi
+	fi
+])
diff --git a/mesos.pc.in b/mesos.pc.in
new file mode 100644
index 0000000..06d68d5
--- /dev/null
+++ b/mesos.pc.in
@@ -0,0 +1,14 @@
+################################
+# Pkg-Config file for mesos    #
+################################
+
+Name: mesos
+Description: Apache Mesos is a cluster manager that provides efficient
+URL: http://mesos.apache.org/
+Version: @VERSION@
+
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+includedir=@includedir@
+libdir=@libdir@
+
diff --git a/src/Makefile.am b/src/Makefile.am
index abef3d2..ddd4e4a 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -19,31 +19,14 @@
 # master/http.cpp and slave/http.cpp.
 AUTOMAKE_OPTIONS = subdir-objects
 
-include ../3rdparty/versions.am
-include ../3rdparty/libprocess/3rdparty/versions.am
-
-# TODO(charles): Move these into an included automakefile and have
-# them include $(top_builddir) as appropriate.
-DISTRIBUTE = 3rdparty/distribute-$(DISTRIBUTE_VERSION)
-LEVELDB = 3rdparty/leveldb
-ZOOKEEPER = 3rdparty/zookeeper-$(ZOOKEEPER_VERSION)/src/c
-LIBPROCESS = 3rdparty/libprocess
-STOUT = $(LIBPROCESS)/3rdparty/stout
-BOOST = $(LIBPROCESS)/3rdparty/boost-$(BOOST_VERSION)
-GLOG = $(LIBPROCESS)/3rdparty/glog-$(GLOG_VERSION)
-GMOCK = $(LIBPROCESS)/3rdparty/gmock-$(GMOCK_VERSION)
-GTEST = $(GMOCK)/gtest
-PROTOBUF = $(LIBPROCESS)/3rdparty/protobuf-$(PROTOBUF_VERSION)
-
-
 # Unfortunatley, 'pkglibexecdir' and 'pkglocalstatedir' are not set
 # before automake 1.11, so we need to set them manually (until we in
 # the future assume an automake version).
 pkglibexecdir = $(libexecdir)/$(PACKAGE)
-pkglocalstatedir = $(localstatedir)/$(PACKAGE)
+pkglocalstatedir = $(sysconfdir)/$(PACKAGE)
 
 # Protocol buffer compiler.
-PROTOC = ../$(PROTOBUF)/src/protoc
+PROTOC = protoc
 PROTOCFLAGS = -I$(top_srcdir)/include/mesos -I$(srcdir)
 
 # Initialize variables here so we can use += operator everywhere else.
@@ -76,18 +59,7 @@ MESOS_CPPFLAGS += -DLIBDIR=\"$(libdir)\"
 MESOS_CPPFLAGS += -DPKGLIBEXECDIR=\"$(pkglibexecdir)\"
 MESOS_CPPFLAGS += -DPKGDATADIR=\"$(pkgdatadir)\"
 MESOS_CPPFLAGS += -I$(top_srcdir)/include
-MESOS_CPPFLAGS += -I$(top_srcdir)/$(LIBPROCESS)/include
-MESOS_CPPFLAGS += -I$(top_srcdir)/$(STOUT)/include
-MESOS_CPPFLAGS += -I../include
-MESOS_CPPFLAGS += -I../$(BOOST)
-MESOS_CPPFLAGS += -I../$(PROTOBUF)/src
-MESOS_CPPFLAGS += -I../$(GLOG)/src
-
-if WITH_INCLUDED_ZOOKEEPER
-  MESOS_CPPFLAGS += -I../$(ZOOKEEPER)/include
-  MESOS_CPPFLAGS += -I../$(ZOOKEEPER)/generated
-endif
-
+MESOS_CPPFLAGS += -I$(top_srcdir)/include/mesos
 
 # README: we build the Mesos library out of a collection of
 # convenience libraries (that is, libraries that do not get installed
@@ -148,7 +120,7 @@ $(PYTHON_PROTOS): $(MESOS_PROTO)
 # self-contained Python library and statically link in the third party
 # libraries themselves.
 noinst_LTLIBRARIES += libmesos_no_3rdparty.la
-
+ 
 nodist_libmesos_no_3rdparty_la_SOURCES =				\
   $(CXX_PROTOS)								\
   $(MESSAGES_PROTOS)							\
@@ -162,10 +134,10 @@ libmesos_no_3rdparty_la_SOURCES =					\
 	sched/sched.cpp							\
 	local/local.cpp							\
 	master/contender.cpp						\
-	master/constants.cpp						\
+	master/m_constants.cpp						\
 	master/detector.cpp						\
 	master/drf_sorter.cpp						\
-	master/http.cpp							\
+	master/m_http.cpp							\
 	master/master.cpp						\
 	master/registry.hpp						\
 	master/registry.proto                                           \
@@ -196,12 +168,6 @@ libmesos_no_3rdparty_la_SOURCES =					\
 	zookeeper/group.cpp						\
 	messages/messages.proto
 
-pkginclude_HEADERS = $(top_srcdir)/include/mesos/executor.hpp	\
-		     $(top_srcdir)/include/mesos/scheduler.hpp	\
-                     $(top_srcdir)/include/mesos/resources.hpp	\
-                     $(top_srcdir)/include/mesos/values.hpp	\
-		     $(top_srcdir)/include/mesos/mesos.proto
-
 nodist_pkginclude_HEADERS = ../include/mesos/mesos.hpp mesos.pb.h
 
 if OS_LINUX
@@ -256,6 +222,38 @@ libmesos_no_3rdparty_la_CPPFLAGS = $(MESOS_CPPFLAGS)
 
 libmesos_no_3rdparty_la_LIBADD = # Initialized to enable using +=.
 
+noinst_LTLIBRARIES += libprocess.la
+
+libprocess_la_SOURCES =		\
+  libprocess/config.hpp		\
+  libprocess/decoder.hpp		\
+  libprocess/encoder.hpp		\
+  libprocess/gate.hpp			\
+  libprocess/latch.cpp			\
+  libprocess/pid.cpp			\
+  libprocess/process.cpp		\
+  libprocess/statistics.cpp		\
+  libprocess/synchronized.hpp
+  
+libprocess_la_CPPFLAGS =		\
+  -I$(top_srcdir)/include/mesos		\
+  -I$(top_srcdir)/src/libprocess	\
+  $(AM_CPPFLAGS)
+
+#
+# libprocess_la_LDFLAGS =			\
+#  -lglog				\
+#  -lhttp_parser				\
+#  -lev					\
+#  -lz
+#
+
+# if HAS_GPERFTOOLS
+# libprocess_la_LDFLAGS += -lprofiler
+# endif
+
+libmesos_no_3rdparty_la_LIBADD += libprocess.la
+
 # Convenience library that *always* gets rebuilt to ensure accurate info.
 noinst_LTLIBRARIES += libbuild.la
 libbuild_la_SOURCES = common/build.cpp
@@ -310,7 +308,7 @@ lib_LTLIBRARIES += libmesos.la
 
 libmesos_la_SOURCES = $(MESOS_PROTO) # Include as part of the distribution.
 
-libmesos_la_LDFLAGS = -release $(PACKAGE_VERSION) -shared
+libmesos_la_LDFLAGS = -version-info 0:0:0 -release $(PACKAGE_VERSION) -shared
 
 # Since we just include the convenience library (and no sources), we
 # need to tell libtool to build this as a C++ library.
@@ -319,23 +317,8 @@ libmesos_la_LIBTOOLFLAGS = --tag=CXX
 # Add the convenience library.
 libmesos_la_LIBADD = libmesos_no_3rdparty.la
 
-# For non-convenience libraries we need to link them in to make the shared
-# library each time. (Currently, we don't support platforms where this is not
-# possible.)
-libmesos_la_LIBADD += ../$(PROTOBUF)/src/libprotobuf.la
-libmesos_la_LIBADD += ../$(GLOG)/libglog.la
-
-# We need to directly include the leveldb library in order to avoid
-# the installed libmesos.la file to include leveldb in
-# 'dependency_libs' (via '-L../3rdparty/leveldb -lleveldb').
-libmesos_la_LIBADD += ../$(LEVELDB)/libleveldb.a
-
-if WITH_INCLUDED_ZOOKEEPER
-  libmesos_la_LIBADD += ../$(ZOOKEEPER)/libzookeeper_mt.la
-endif
-
-libmesos_la_LIBADD += ../$(LIBPROCESS)/libprocess.la
-
+# TODO (tstclair) enable --with-DEP=foo
+libmesos_la_LDFLAGS += -lprotobuf -lglog -lleveldb -lzookeeper_mt -lrt -lcurl -lhttp_parser -lev
 
 # Binaries.
 sbin_PROGRAMS += mesos-master
@@ -505,7 +488,8 @@ EXTRA_DIST += $(EXAMPLES_SOURCE)
 
 if HAS_JAVA
 # Protocol buffers JAR.
-PROTOBUF_JAR = ../protobuf-$(PROTOBUF_VERSION).jar
+# TODO: This should be searched for in configure
+PROTOBUF_JAR =  /usr/share/java/protobuf.jar
 
 # TODO(charles): Move into 3rdparty/Makefile.am.
 $(PROTOBUF_JAR): # TODO(charles): Specify dependencies for the jar.
@@ -689,8 +673,7 @@ PROTOBUF_EGG = ../$(PROTOBUF)/python/dist/protobuf-$(PROTOBUF_EGG_SUFFIX)
 
 $(PROTOBUF_EGG):
 	@echo "Building protobuf Python egg ..."
-	cd ../$(PROTOBUF)/python && \
-	  PYTHONPATH=$(DISTRIBUTE_EGG) $(PYTHON) setup.py bdist_egg
+	  PYTHONPATH=$(DISTRIBUTE_EGG) $(PYTHON) ./python/setup.py bdist_egg
 
 CLEANFILES += $(PROTOBUF_EGG)
 
@@ -781,7 +764,34 @@ balloon_executor_SOURCES = examples/balloon_executor.cpp
 balloon_executor_CPPFLAGS = $(MESOS_CPPFLAGS)
 balloon_executor_LDADD = libmesos.la
 
-check_PROGRAMS += mesos-tests
+check_PROGRAMS += lptests mesos-tests
+
+lptests_SOURCES =							\
+  libprocess/tests/decoder_tests.cpp					\
+  libprocess/tests/encoder_tests.cpp					\
+  libprocess/tests/http_tests.cpp					\
+  libprocess/tests/io_tests.cpp					\
+  libprocess/tests/main.cpp						\
+  libprocess/tests/process_tests.cpp					\
+  libprocess/tests/shared_tests.cpp				\
+  libprocess/tests/statistics_tests.cpp				\
+  libprocess/tests/time_tests.cpp 					\
+  gmock-all.cc
+
+lptests_CPPFLAGS =			\
+  -I$(top_srcdir)/include/mesos		\
+  -I$(top_srcdir)/src/libprocess	\
+  -I/usr/src/gmock			\
+  $(libprocess_la_CPPFLAGS)  
+
+lptests_LDADD =				\
+  -lpthread				\
+  libprocess.la				\
+  -lglog				\
+  -lgtest				\
+  -lhttp_parser				\
+  -lev					\
+  -lz
 
 mesos_tests_SOURCES =				\
   tests/allocator_tests.cpp			\
@@ -815,15 +825,16 @@ mesos_tests_SOURCES =				\
   tests/state_tests.cpp				\
   tests/status_update_manager_tests.cpp		\
   tests/utils.cpp				\
-  tests/zookeeper_url_tests.cpp
+  tests/zookeeper_url_tests.cpp \
+  gmock-all.cc
 
 mesos_tests_CPPFLAGS = $(MESOS_CPPFLAGS)
 mesos_tests_CPPFLAGS += -DSOURCE_DIR=\"$(abs_top_srcdir)\"
 mesos_tests_CPPFLAGS += -DBUILD_DIR=\"$(abs_top_builddir)\"
 mesos_tests_CPPFLAGS += -I../$(GTEST)/include
-mesos_tests_CPPFLAGS += -I../$(GMOCK)/include
-
-mesos_tests_LDADD = ../$(LIBPROCESS)/3rdparty/libgmock.la libmesos.la
+mesos_tests_CPPFLAGS += -I/usr/src/gmock
+ 
+mesos_tests_LDADD = libmesos.la -lgtest -lsasl2
 
 mesos_tests_DEPENDENCIES = # Initialized to allow += below.
 
@@ -881,8 +892,8 @@ dist_check_SCRIPTS +=							\
 # runner that ships with newer versions of autotools.
 # See the following discussion for the workaround:
 # http://lists.gnu.org/archive/html/automake/2013-01/msg00051.html
-check-local: mesos-tests
-	./mesos-tests
+check-local: mesos-tests lptests
+	./lptests && ./mesos-tests 
 
 clean-local: clean-java clean-python
 
diff --git a/src/deploy/mesos-daemon.sh.in b/src/deploy/mesos-daemon.sh.in
index 2242ed1..6d019e9 100644
--- a/src/deploy/mesos-daemon.sh.in
+++ b/src/deploy/mesos-daemon.sh.in
@@ -3,7 +3,7 @@
 prefix=@prefix@
 exec_prefix=@exec_prefix@
 
-deploy_dir=@localstatedir@/@PACKAGE@/deploy
+deploy_dir=@sysconfdir@/@PACKAGE@
 
 # Increase the default number of open file descriptors.
 ulimit -n 8192
@@ -12,7 +12,6 @@ PROGRAM=${1}
 
 shift # Remove PROGRAM from the argument list (since we pass ${@} below).
 
-test -e ${deploy_dir}/${PROGRAM}-env.sh && \
-. ${deploy_dir}/${PROGRAM}-env.sh
+test -e ${deploy_dir}/${PROGRAM}-env && source ${deploy_dir}/${PROGRAM}-env.sh
 
 nohup @sbindir@/${PROGRAM} ${@} </dev/null >/dev/null 2>&1 &
diff --git a/src/deploy/mesos-deploy-env.sh.template b/src/deploy/mesos-deploy-env.sh.template
index afc6197..381951c 100644
--- a/src/deploy/mesos-deploy-env.sh.template
+++ b/src/deploy/mesos-deploy-env.sh.template
@@ -1,4 +1,3 @@
-#!/bin/sh
 
 # This file contains environment variables that modify how the deploy
 # scripts are run. For example, it can be used to configure SSH
@@ -10,4 +9,4 @@ export SSH_OPTS="-o StrictHostKeyChecking=no -o ConnectTimeout=2"
 
 
 # Use sudo for launching masters and slaves.
-#export DEPLOY_WITH_SUDO=1
\ No newline at end of file
+#export DEPLOY_WITH_SUDO=1
diff --git a/src/deploy/mesos-start-cluster.sh.in b/src/deploy/mesos-start-cluster.sh.in
index fa27de0..210545c 100644
--- a/src/deploy/mesos-start-cluster.sh.in
+++ b/src/deploy/mesos-start-cluster.sh.in
@@ -3,11 +3,10 @@
 prefix=@prefix@
 exec_prefix=@exec_prefix@
 
-DEPLOY_DIR=@localstatedir@/@PACKAGE@/deploy
+DEPLOY_DIR=@sysconfdir@/@PACKAGE@
 
 # Pull in deploy specific options.
-test -e ${DEPLOY_DIR}/mesos-deploy-env.sh && \
-  . ${DEPLOY_DIR}/mesos-deploy-env.sh
+test -e ${DEPLOY_DIR}/mesos-deploy-env && source ${DEPLOY_DIR}/mesos-deploy-env.sh
 
 usage() {
   echo "Usage: mesos-start-cluster.sh [-h] [-s]"
diff --git a/src/deploy/mesos-start-masters.sh.in b/src/deploy/mesos-start-masters.sh.in
index 3f0f524..d0f6f68 100644
--- a/src/deploy/mesos-start-masters.sh.in
+++ b/src/deploy/mesos-start-masters.sh.in
@@ -3,11 +3,10 @@
 prefix=@prefix@
 exec_prefix=@exec_prefix@
 
-DEPLOY_DIR=@localstatedir@/@PACKAGE@/deploy
+DEPLOY_DIR=@sysconfdir@/@PACKAGE@
 
 # Pull in deploy specific options.
-test -e ${DEPLOY_DIR}/mesos-deploy-env.sh && \
-  . ${DEPLOY_DIR}/mesos-deploy-env.sh
+test -e ${DEPLOY_DIR}/mesos-deploy-env && source ${DEPLOY_DIR}/mesos-deploy-env.sh
 
 # Find the list of masters.
 MASTERS_FILE="${DEPLOY_DIR}/masters"
diff --git a/src/deploy/mesos-start-slaves.sh.in b/src/deploy/mesos-start-slaves.sh.in
index 7283e88..05c9717 100644
--- a/src/deploy/mesos-start-slaves.sh.in
+++ b/src/deploy/mesos-start-slaves.sh.in
@@ -3,11 +3,10 @@
 prefix=@prefix@
 exec_prefix=@exec_prefix@
 
-DEPLOY_DIR=@localstatedir@/@PACKAGE@/deploy
+DEPLOY_DIR=@sysconfdir@/@PACKAGE@
 
 # Pull in deploy specific options.
-test -e ${DEPLOY_DIR}/mesos-deploy-env.sh && \
-  . ${DEPLOY_DIR}/mesos-deploy-env.sh
+test -e ${DEPLOY_DIR}/mesos-deploy-env && source ${DEPLOY_DIR}/mesos-deploy-env.sh
 
 # Find the list of slaves.
 SLAVES_FILE="${DEPLOY_DIR}/slaves"
diff --git a/src/deploy/mesos-stop-masters.sh.in b/src/deploy/mesos-stop-masters.sh.in
index 993bc64..8caa17e 100644
--- a/src/deploy/mesos-stop-masters.sh.in
+++ b/src/deploy/mesos-stop-masters.sh.in
@@ -2,11 +2,10 @@
 
 prefix=@prefix@
 
-DEPLOY_DIR=@localstatedir@/@PACKAGE@/deploy
+DEPLOY_DIR=@sysconfdir@/@PACKAGE@
 
 # Pull in deploy specific options.
-test -e ${DEPLOY_DIR}/mesos-deploy-env.sh && \
-  . ${DEPLOY_DIR}/mesos-deploy-env.sh
+test -e ${DEPLOY_DIR}/mesos-deploy-env && source ${DEPLOY_DIR}/mesos-deploy-env.sh
 
 # Find the list of masters.
 MASTERS_FILE="${DEPLOY_DIR}/masters"
diff --git a/src/deploy/mesos-stop-slaves.sh.in b/src/deploy/mesos-stop-slaves.sh.in
index dd0c2b8..e812c1c 100644
--- a/src/deploy/mesos-stop-slaves.sh.in
+++ b/src/deploy/mesos-stop-slaves.sh.in
@@ -1,11 +1,10 @@
 #!/bin/sh
 
 prefix=@prefix@
-DEPLOY_DIR=@localstatedir@/@PACKAGE@/deploy
+DEPLOY_DIR=@sysconfdir@/@PACKAGE@
 
 # Pull in deploy specific options.
-test -e ${DEPLOY_DIR}/mesos-deploy-env.sh && \
-  . ${DEPLOY_DIR}/mesos-deploy-env.sh
+test -e ${DEPLOY_DIR}/mesos-deploy-env && source ${DEPLOY_DIR}/mesos-deploy-env.sh
 
 # Find the list of slaves.
 SLAVES_FILE="${DEPLOY_DIR}/slaves"
diff --git a/src/examples/java/test-framework.in b/src/examples/java/test-framework.in
index 251a758..1e232b2 100644
--- a/src/examples/java/test-framework.in
+++ b/src/examples/java/test-framework.in
@@ -12,7 +12,8 @@ JAVA=${JAVA-${JAVA_HOME}/bin/java}
 # Use colors for errors.
 . ${MESOS_SOURCE_DIR}/support/colors.sh
 
-PROTOBUF_JAR=${MESOS_BUILD_DIR}/protobuf-2.4.1.jar
+# TODO:tstclair - this should be discovered using --with
+PROTOBUF_JAR=/usr/share/java/protobuf.jar
 
 test ! -e ${PROTOBUF_JAR} && \
   echo "${RED}Failed to find ${PROTOBUF_JAR}${NORMAL}" && \
diff --git a/src/examples/python/test-executor.in b/src/examples/python/test-executor.in
index 6f18682..615ed96 100644
--- a/src/examples/python/test-executor.in
+++ b/src/examples/python/test-executor.in
@@ -14,19 +14,6 @@ test ! -z "${PYTHON}" && \
 
 PYTHON=@PYTHON@
 
-DISTRIBUTE_EGG=`echo ${MESOS_BUILD_DIR}/3rdparty/distribute-*/dist/*.egg`
-
-test ! -e ${DISTRIBUTE_EGG} && \
-  echo "${RED}Failed to find ${DISTRIBUTE_EGG}${NORMAL}" && \
-  exit 1
-
-PROTOBUF=${MESOS_BUILD_DIR}/3rdparty/libprocess/3rdparty/protobuf-2.4.1
-PROTOBUF_EGG=`echo ${PROTOBUF}/python/dist/protobuf*.egg`
-
-test ! -e ${PROTOBUF_EGG} && \
-  echo "${RED}Failed to find ${PROTOBUF_EGG}${NORMAL}" && \
-  exit 1
-
 MESOS_EGG=`echo ${MESOS_BUILD_DIR}/src/python/dist/mesos*.egg`
 
 test ! -e ${MESOS_EGG} && \
@@ -39,5 +26,5 @@ test ! -e ${SCRIPT} && \
   echo "${RED}Failed to find ${SCRIPT}${NORMAL}" && \
   exit 1
 
-PYTHONPATH="${DISTRIBUTE_EGG}:${MESOS_EGG}:${PROTOBUF_EGG}" \
+PYTHONPATH="${MESOS_EGG}" \
   exec ${PYTHON} ${SCRIPT} "${@}"
diff --git a/src/examples/python/test-framework.in b/src/examples/python/test-framework.in
index d66cf6b..ba86362 100644
--- a/src/examples/python/test-framework.in
+++ b/src/examples/python/test-framework.in
@@ -14,19 +14,6 @@ test ! -z "${PYTHON}" && \
 
 PYTHON=@PYTHON@
 
-DISTRIBUTE_EGG=`echo ${MESOS_BUILD_DIR}/3rdparty/distribute-*/dist/*.egg`
-
-test ! -e ${DISTRIBUTE_EGG} && \
-  echo "${RED}Failed to find ${DISTRIBUTE_EGG}${NORMAL}" && \
-  exit 1
-
-PROTOBUF=${MESOS_BUILD_DIR}/3rdparty/libprocess/3rdparty/protobuf-2.4.1
-PROTOBUF_EGG=`echo ${PROTOBUF}/python/dist/protobuf*.egg`
-
-test ! -e ${PROTOBUF_EGG} && \
-  echo "${RED}Failed to find ${PROTOBUF_EGG}${NORMAL}" && \
-  exit 1
-
 MESOS_EGG=`echo ${MESOS_BUILD_DIR}/src/python/dist/mesos*.egg`
 
 test ! -e ${MESOS_EGG} && \
@@ -43,5 +30,5 @@ test ! -e ${SCRIPT} && \
 # framework is able to find the executor.
 cd `dirname ${0}`
 
-PYTHONPATH="${DISTRIBUTE_EGG}:${MESOS_EGG}:${PROTOBUF_EGG}" \
+PYTHONPATH="${MESOS_EGG}" \
   exec ${PYTHON} ${SCRIPT} "${@}"
diff --git a/src/jvm/org/apache/zookeeper.hpp b/src/jvm/org/apache/zookeeper.hpp
index dac1456..80f98b9 100644
--- a/src/jvm/org/apache/zookeeper.hpp
+++ b/src/jvm/org/apache/zookeeper.hpp
@@ -113,18 +113,20 @@ public:
     {
       static Jvm::Constructor constructor = Jvm::get()->findConstructor(
           Jvm::Class::named(
-              "org/apache/zookeeper/server/NIOServerCnxn$Factory")
-          .constructor()
-          .parameter(Jvm::Class::named("java/net/InetSocketAddress")));
+              "org/apache/zookeeper/server/NIOServerCnxnFactory")
+          .constructor());
 
-      object = Jvm::get()->invoke(constructor, (jobject) addr);
+      //TODO may need to #if version this
+      
+      object = Jvm::get()->invoke(constructor);
+      this->configure(addr);
     }
 
     void startup(const ZooKeeperServer& zks)
     {
       static Jvm::Method method = Jvm::get()->findMethod(
           Jvm::Class::named(
-              "org/apache/zookeeper/server/NIOServerCnxn$Factory")
+              "org/apache/zookeeper/server/NIOServerCnxnFactory")
           .method("startup")
           .parameter(Jvm::Class::named(
                          "org/apache/zookeeper/server/ZooKeeperServer"))
@@ -133,6 +135,19 @@ public:
       Jvm::get()->invoke<void>(object, method, (jobject) zks);
     }
 
+    void configure(const java::net::InetSocketAddress& addr, const int maxcc=0)
+    {
+        static Jvm::Method method = Jvm::get()->findMethod(
+            Jvm::Class::named(
+                "org/apache/zookeeper/server/NIOServerCnxnFactory")
+            .method("configure")
+            .parameter(Jvm::Class::named("java/net/InetSocketAddress"))
+            .parameter(Jvm::get()->intClass)
+            .returns(Jvm::get()->voidClass));
+        
+        Jvm::get()->invoke<void>(object, method, (jobject) addr, maxcc);
+    }
+#if 0
     bool isAlive()
     {
       static Jvm::Method method = Jvm::get()->findMethod(
@@ -143,12 +158,13 @@ public:
 
       return Jvm::get()->invoke<bool>(object, method);
     }
-
+#endif
+    
     void shutdown()
     {
       static Jvm::Method method = Jvm::get()->findMethod(
           Jvm::Class::named(
-              "org/apache/zookeeper/server/NIOServerCnxn$Factory")
+              "org/apache/zookeeper/server/NIOServerCnxnFactory")
           .method("shutdown")
           .returns(Jvm::get()->voidClass));
 
diff --git a/src/master/constants.cpp b/src/master/constants.cpp
deleted file mode 100644
index 4475a0d..0000000
--- a/src/master/constants.cpp
+++ /dev/null
@@ -1,38 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stout/bytes.hpp>
-
-#include "master/constants.hpp"
-
-namespace mesos {
-namespace internal {
-namespace master {
-
-const int MAX_OFFERS_PER_FRAMEWORK = 50;
-const double MIN_CPUS = 0.1;
-const Bytes MIN_MEM = Megabytes(32);
-const Duration SLAVE_PING_TIMEOUT = Seconds(15);
-const uint32_t MAX_SLAVE_PING_TIMEOUTS = 5;
-const uint32_t MAX_COMPLETED_FRAMEWORKS = 50;
-const uint32_t MAX_COMPLETED_TASKS_PER_FRAMEWORK = 1000;
-const Duration WHITELIST_WATCH_INTERVAL = Seconds(5);
-
-} // namespace mesos {
-} // namespace internal {
-} // namespace master {
diff --git a/src/master/http.cpp b/src/master/http.cpp
deleted file mode 100644
index 218906a..0000000
--- a/src/master/http.cpp
+++ /dev/null
@@ -1,461 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <iomanip>
-#include <map>
-#include <sstream>
-#include <string>
-#include <vector>
-
-#include <mesos/mesos.hpp>
-#include <mesos/resources.hpp>
-
-#include <process/help.hpp>
-
-#include <stout/foreach.hpp>
-#include <stout/json.hpp>
-#include <stout/net.hpp>
-#include <stout/numify.hpp>
-#include <stout/os.hpp>
-#include <stout/result.hpp>
-#include <stout/strings.hpp>
-
-#include "common/attributes.hpp"
-#include "common/build.hpp"
-#include "common/type_utils.hpp"
-#include "common/protobuf_utils.hpp"
-
-#include "logging/logging.hpp"
-
-#include "master/master.hpp"
-
-namespace mesos {
-namespace internal {
-namespace master {
-
-using process::Future;
-using process::HELP;
-using process::TLDR;
-using process::USAGE;
-
-using process::http::BadRequest;
-using process::http::InternalServerError;
-using process::http::NotFound;
-using process::http::OK;
-using process::http::TemporaryRedirect;
-using process::http::Response;
-using process::http::Request;
-
-using std::map;
-using std::string;
-using std::vector;
-
-// TODO(bmahler): Kill these in favor of automatic Proto->JSON Conversion (when
-// it becomes available).
-
-// Returns a JSON object modeled on a Resources.
-JSON::Object model(const Resources& resources)
-{
-  JSON::Object object;
-
-  foreach (const Resource& resource, resources) {
-    switch (resource.type()) {
-      case Value::SCALAR:
-        object.values[resource.name()] = resource.scalar().value();
-        break;
-      case Value::RANGES:
-        object.values[resource.name()] = stringify(resource.ranges());
-        break;
-      case Value::SET:
-        object.values[resource.name()] = stringify(resource.set());
-        break;
-      default:
-        LOG(FATAL) << "Unexpected Value type: " << resource.type();
-        break;
-    }
-  }
-
-  return object;
-}
-
-
-JSON::Object model(const Attributes& attributes)
-{
-  JSON::Object object;
-
-  foreach (const Attribute& attribute, attributes) {
-    switch (attribute.type()) {
-      case Value::SCALAR:
-        object.values[attribute.name()] = attribute.scalar().value();
-        break;
-      case Value::RANGES:
-        object.values[attribute.name()] = stringify(attribute.ranges());
-        break;
-      case Value::SET:
-        object.values[attribute.name()] = stringify(attribute.set());
-        break;
-      case Value::TEXT:
-        object.values[attribute.name()] = attribute.text().value();
-        break;
-      default:
-        LOG(FATAL) << "Unexpected Value type: " << attribute.type();
-        break;
-    }
-  }
-
-  return object;
-}
-
-
-// Returns a JSON object modeled on a TaskStatus.
-JSON::Object model(const TaskStatus& status)
-{
-  JSON::Object object;
-  object.values["state"] = TaskState_Name(status.state());
-  object.values["timestamp"] = status.timestamp();
-
-  return object;
-}
-
-
-// Returns a JSON object modeled on a Task.
-// TODO(bmahler): Expose the executor name / source.
-JSON::Object model(const Task& task)
-{
-  JSON::Object object;
-  object.values["id"] = task.task_id().value();
-  object.values["name"] = task.name();
-  object.values["framework_id"] = task.framework_id().value();
-  object.values["executor_id"] = task.executor_id().value();
-  object.values["slave_id"] = task.slave_id().value();
-  object.values["state"] = TaskState_Name(task.state());
-  object.values["resources"] = model(task.resources());
-
-  JSON::Array array;
-  foreach (const TaskStatus& status, task.statuses()) {
-    array.values.push_back(model(status));
-  }
-  object.values["statuses"] = array;
-
-  return object;
-}
-
-
-// Returns a JSON object modeled on an Offer.
-JSON::Object model(const Offer& offer)
-{
-  JSON::Object object;
-  object.values["id"] = offer.id().value();
-  object.values["framework_id"] = offer.framework_id().value();
-  object.values["slave_id"] = offer.slave_id().value();
-  object.values["resources"] = model(offer.resources());
-  return object;
-}
-
-
-// Returns a JSON object modeled on a Framework.
-JSON::Object model(const Framework& framework)
-{
-  JSON::Object object;
-  object.values["id"] = framework.id.value();
-  object.values["name"] = framework.info.name();
-  object.values["user"] = framework.info.user();
-  object.values["registered_time"] = framework.registeredTime.secs();
-  object.values["unregistered_time"] = framework.unregisteredTime.secs();
-  object.values["active"] = framework.active;
-  object.values["resources"] = model(framework.resources);
-
-  // TODO(benh): Consider making reregisteredTime an Option.
-  if (framework.registeredTime != framework.reregisteredTime) {
-    object.values["reregistered_time"] = framework.reregisteredTime.secs();
-  }
-
-  // Model all of the tasks associated with a framework.
-  {
-    JSON::Array array;
-    foreachvalue (Task* task, framework.tasks) {
-      array.values.push_back(model(*task));
-    }
-
-    object.values["tasks"] = array;
-  }
-
-  // Model all of the completed tasks of a framework.
-  {
-    JSON::Array array;
-    foreach (const Task& task, framework.completedTasks) {
-      array.values.push_back(model(task));
-    }
-
-    object.values["completed_tasks"] = array;
-  }
-
-  // Model all of the offers associated with a framework.
-  {
-    JSON::Array array;
-    foreach (Offer* offer, framework.offers) {
-      array.values.push_back(model(*offer));
-    }
-
-    object.values["offers"] = array;
-  }
-
-  return object;
-}
-
-
-// Returns a JSON object modeled after a Slave.
-JSON::Object model(const Slave& slave)
-{
-  JSON::Object object;
-  object.values["id"] = slave.id.value();
-  object.values["pid"] = string(slave.pid);
-  object.values["hostname"] = slave.info.hostname();
-  object.values["registered_time"] = slave.registeredTime.secs();
-
-  if (slave.reregisteredTime.isSome()) {
-    object.values["reregistered_time"] = slave.reregisteredTime.get().secs();
-  }
-
-  object.values["resources"] = model(slave.info.resources());
-  object.values["attributes"] = model(slave.info.attributes());
-  return object;
-}
-
-// Returns a JSON object modeled after a Role.
-JSON::Object model(const Role& role)
-{
-  JSON::Object object;
-  object.values["name"] = role.info.name();
-  object.values["weight"] = role.info.weight();
-  object.values["resources"] = model(role.resources());
-
-  {
-    JSON::Array array;
-
-    foreachkey (const FrameworkID& frameworkId, role.frameworks) {
-      array.values.push_back(frameworkId.value());
-    }
-
-    object.values["frameworks"] = array;
-  }
-
-  return object;
-}
-
-
-const string Master::Http::HEALTH_HELP = HELP(
-    TLDR(
-        "Health check of the Master."),
-    USAGE(
-        "/master/health"),
-    DESCRIPTION(
-        "Returns 200 OK iff the Master is healthy.",
-        "Delayed responses are also indicative of poor health."));
-
-
-Future<Response> Master::Http::health(const Request& request)
-{
-  return OK();
-}
-
-
-const string Master::Http::REDIRECT_HELP = HELP(
-    TLDR(
-        "Redirects to the leading Master."),
-    USAGE(
-        "/master/redirect"),
-    DESCRIPTION(
-        "This returns a 307 Temporary Redirect to the leading Master.",
-        "If no Master is leading (according to this Master), then the",
-        "Master will redirect to itself.",
-        "",
-        "**NOTES:**",
-        "1. This is the recommended way to bookmark the WebUI when",
-        "running multiple Masters.",
-        "2. This is broken currently \"on the cloud\" (e.g. EC2) as",
-        "this will attempt to redirect to the private IP address."));
-
-
-
-Future<Response> Master::Http::redirect(const Request& request)
-{
-  LOG(INFO) << "HTTP request for '" << request.path << "'";
-
-  // If there's no leader, redirect to this master's base url.
-  UPID pid = master.leader.isSome() ? master.leader.get() : master.self();
-
-  Try<string> hostname = net::getHostname(pid.ip);
-  if (hostname.isError()) {
-    return InternalServerError(hostname.error());
-  }
-
-  return TemporaryRedirect(
-      "http://" + hostname.get() + ":" + stringify(pid.port));
-}
-
-
-Future<Response> Master::Http::stats(const Request& request)
-{
-  LOG(INFO) << "HTTP request for '" << request.path << "'";
-
-  JSON::Object object;
-  object.values["uptime"] = (Clock::now() - master.startTime).secs();
-  object.values["elected"] = master.elected(); // Note: using int not bool.
-  object.values["total_schedulers"] = master.frameworks.size();
-  object.values["active_schedulers"] = master.getActiveFrameworks().size();
-  object.values["activated_slaves"] = master.slaves.size();
-  object.values["deactivated_slaves"] = master.deactivatedSlaves.size();
-  object.values["staged_tasks"] = master.stats.tasks[TASK_STAGING];
-  object.values["started_tasks"] = master.stats.tasks[TASK_STARTING];
-  object.values["finished_tasks"] = master.stats.tasks[TASK_FINISHED];
-  object.values["killed_tasks"] = master.stats.tasks[TASK_KILLED];
-  object.values["failed_tasks"] = master.stats.tasks[TASK_FAILED];
-  object.values["lost_tasks"] = master.stats.tasks[TASK_LOST];
-  object.values["valid_status_updates"] = master.stats.validStatusUpdates;
-  object.values["invalid_status_updates"] = master.stats.invalidStatusUpdates;
-  object.values["outstanding_offers"] = master.offers.size();
-
-  // Get total and used (note, not offered) resources in order to
-  // compute capacity of scalar resources.
-  Resources totalResources;
-  Resources usedResources;
-  foreachvalue (Slave* slave, master.slaves) {
-    // Instead of accumulating all types of resources (which is
-    // not necessary), we only accumulate scalar resources. This
-    // helps us bypass a performance problem caused by range
-    // additions (e.g. ports).
-    foreach (const Resource& resource, slave->info.resources()) {
-      if (resource.type() == Value::SCALAR) {
-        totalResources += resource;
-      }
-    }
-    foreach (const Resource& resource, slave->resourcesInUse) {
-      if (resource.type() == Value::SCALAR) {
-        usedResources += resource;
-      }
-    }
-  }
-
-  foreach (const Resource& resource, totalResources) {
-    CHECK(resource.has_scalar());
-    double total = resource.scalar().value();
-    object.values[resource.name() + "_total"] = total;
-    Option<Resource> option = usedResources.get(resource);
-    CHECK(!option.isSome() || option.get().has_scalar());
-    double used = option.isSome() ? option.get().scalar().value() : 0.0;
-    object.values[resource.name() + "_used"] = used;
-    double percent = used / total;
-    object.values[resource.name() + "_percent"] = percent;
-  }
-
-  return OK(object, request.query.get("jsonp"));
-}
-
-
-Future<Response> Master::Http::state(const Request& request)
-{
-  LOG(INFO) << "HTTP request for '" << request.path << "'";
-
-  JSON::Object object;
-  object.values["version"] = MESOS_VERSION;
-  object.values["build_date"] = build::DATE;
-  object.values["build_time"] = build::TIME;
-  object.values["build_user"] = build::USER;
-  object.values["start_time"] = master.startTime.secs();
-  object.values["id"] = master.info.id();
-  object.values["pid"] = string(master.self());
-  object.values["activated_slaves"] = master.slaves.size();
-  object.values["deactivated_slaves"] = master.deactivatedSlaves.size();
-  object.values["staged_tasks"] = master.stats.tasks[TASK_STAGING];
-  object.values["started_tasks"] = master.stats.tasks[TASK_STARTING];
-  object.values["finished_tasks"] = master.stats.tasks[TASK_FINISHED];
-  object.values["killed_tasks"] = master.stats.tasks[TASK_KILLED];
-  object.values["failed_tasks"] = master.stats.tasks[TASK_FAILED];
-  object.values["lost_tasks"] = master.stats.tasks[TASK_LOST];
-
-  if (master.flags.cluster.isSome()) {
-    object.values["cluster"] = master.flags.cluster.get();
-  }
-
-  if (master.leader.isSome()) {
-    object.values["leader"] = string(master.leader.get());
-  }
-
-  if (master.flags.log_dir.isSome()) {
-    object.values["log_dir"] = master.flags.log_dir.get();
-  }
-
-  // Model all of the slaves.
-  {
-    JSON::Array array;
-    foreachvalue (Slave* slave, master.slaves) {
-      array.values.push_back(model(*slave));
-    }
-
-    object.values["slaves"] = array;
-  }
-
-  // Model all of the frameworks.
-  {
-    JSON::Array array;
-    foreachvalue (Framework* framework, master.frameworks) {
-      array.values.push_back(model(*framework));
-    }
-
-    object.values["frameworks"] = array;
-  }
-
-  // Model all of the completed frameworks.
-  {
-    JSON::Array array;
-
-    foreach (const std::tr1::shared_ptr<Framework>& framework,
-             master.completedFrameworks) {
-      array.values.push_back(model(*framework));
-    }
-
-    object.values["completed_frameworks"] = array;
-  }
-
-  return OK(object, request.query.get("jsonp"));
-}
-
-
-Future<Response> Master::Http::roles(const Request& request)
-{
-  LOG(INFO) << "HTTP request for '" << request.path << "'";
-
-  JSON::Object object;
-
-  // Model all of the roles.
-  {
-    JSON::Array array;
-    foreachvalue (Role* role, master.roles) {
-      array.values.push_back(model(*role));
-    }
-
-    object.values["roles"] = array;
-  }
-
-  return OK(object, request.query.get("jsonp"));
-}
-
-} // namespace master {
-} // namespace internal {
-} // namespace mesos {
diff --git a/src/master/m_constants.cpp b/src/master/m_constants.cpp
new file mode 100644
index 0000000..4475a0d
--- /dev/null
+++ b/src/master/m_constants.cpp
@@ -0,0 +1,38 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stout/bytes.hpp>
+
+#include "master/constants.hpp"
+
+namespace mesos {
+namespace internal {
+namespace master {
+
+const int MAX_OFFERS_PER_FRAMEWORK = 50;
+const double MIN_CPUS = 0.1;
+const Bytes MIN_MEM = Megabytes(32);
+const Duration SLAVE_PING_TIMEOUT = Seconds(15);
+const uint32_t MAX_SLAVE_PING_TIMEOUTS = 5;
+const uint32_t MAX_COMPLETED_FRAMEWORKS = 50;
+const uint32_t MAX_COMPLETED_TASKS_PER_FRAMEWORK = 1000;
+const Duration WHITELIST_WATCH_INTERVAL = Seconds(5);
+
+} // namespace mesos {
+} // namespace internal {
+} // namespace master {
diff --git a/src/master/m_http.cpp b/src/master/m_http.cpp
new file mode 100644
index 0000000..218906a
--- /dev/null
+++ b/src/master/m_http.cpp
@@ -0,0 +1,461 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iomanip>
+#include <map>
+#include <sstream>
+#include <string>
+#include <vector>
+
+#include <mesos/mesos.hpp>
+#include <mesos/resources.hpp>
+
+#include <process/help.hpp>
+
+#include <stout/foreach.hpp>
+#include <stout/json.hpp>
+#include <stout/net.hpp>
+#include <stout/numify.hpp>
+#include <stout/os.hpp>
+#include <stout/result.hpp>
+#include <stout/strings.hpp>
+
+#include "common/attributes.hpp"
+#include "common/build.hpp"
+#include "common/type_utils.hpp"
+#include "common/protobuf_utils.hpp"
+
+#include "logging/logging.hpp"
+
+#include "master/master.hpp"
+
+namespace mesos {
+namespace internal {
+namespace master {
+
+using process::Future;
+using process::HELP;
+using process::TLDR;
+using process::USAGE;
+
+using process::http::BadRequest;
+using process::http::InternalServerError;
+using process::http::NotFound;
+using process::http::OK;
+using process::http::TemporaryRedirect;
+using process::http::Response;
+using process::http::Request;
+
+using std::map;
+using std::string;
+using std::vector;
+
+// TODO(bmahler): Kill these in favor of automatic Proto->JSON Conversion (when
+// it becomes available).
+
+// Returns a JSON object modeled on a Resources.
+JSON::Object model(const Resources& resources)
+{
+  JSON::Object object;
+
+  foreach (const Resource& resource, resources) {
+    switch (resource.type()) {
+      case Value::SCALAR:
+        object.values[resource.name()] = resource.scalar().value();
+        break;
+      case Value::RANGES:
+        object.values[resource.name()] = stringify(resource.ranges());
+        break;
+      case Value::SET:
+        object.values[resource.name()] = stringify(resource.set());
+        break;
+      default:
+        LOG(FATAL) << "Unexpected Value type: " << resource.type();
+        break;
+    }
+  }
+
+  return object;
+}
+
+
+JSON::Object model(const Attributes& attributes)
+{
+  JSON::Object object;
+
+  foreach (const Attribute& attribute, attributes) {
+    switch (attribute.type()) {
+      case Value::SCALAR:
+        object.values[attribute.name()] = attribute.scalar().value();
+        break;
+      case Value::RANGES:
+        object.values[attribute.name()] = stringify(attribute.ranges());
+        break;
+      case Value::SET:
+        object.values[attribute.name()] = stringify(attribute.set());
+        break;
+      case Value::TEXT:
+        object.values[attribute.name()] = attribute.text().value();
+        break;
+      default:
+        LOG(FATAL) << "Unexpected Value type: " << attribute.type();
+        break;
+    }
+  }
+
+  return object;
+}
+
+
+// Returns a JSON object modeled on a TaskStatus.
+JSON::Object model(const TaskStatus& status)
+{
+  JSON::Object object;
+  object.values["state"] = TaskState_Name(status.state());
+  object.values["timestamp"] = status.timestamp();
+
+  return object;
+}
+
+
+// Returns a JSON object modeled on a Task.
+// TODO(bmahler): Expose the executor name / source.
+JSON::Object model(const Task& task)
+{
+  JSON::Object object;
+  object.values["id"] = task.task_id().value();
+  object.values["name"] = task.name();
+  object.values["framework_id"] = task.framework_id().value();
+  object.values["executor_id"] = task.executor_id().value();
+  object.values["slave_id"] = task.slave_id().value();
+  object.values["state"] = TaskState_Name(task.state());
+  object.values["resources"] = model(task.resources());
+
+  JSON::Array array;
+  foreach (const TaskStatus& status, task.statuses()) {
+    array.values.push_back(model(status));
+  }
+  object.values["statuses"] = array;
+
+  return object;
+}
+
+
+// Returns a JSON object modeled on an Offer.
+JSON::Object model(const Offer& offer)
+{
+  JSON::Object object;
+  object.values["id"] = offer.id().value();
+  object.values["framework_id"] = offer.framework_id().value();
+  object.values["slave_id"] = offer.slave_id().value();
+  object.values["resources"] = model(offer.resources());
+  return object;
+}
+
+
+// Returns a JSON object modeled on a Framework.
+JSON::Object model(const Framework& framework)
+{
+  JSON::Object object;
+  object.values["id"] = framework.id.value();
+  object.values["name"] = framework.info.name();
+  object.values["user"] = framework.info.user();
+  object.values["registered_time"] = framework.registeredTime.secs();
+  object.values["unregistered_time"] = framework.unregisteredTime.secs();
+  object.values["active"] = framework.active;
+  object.values["resources"] = model(framework.resources);
+
+  // TODO(benh): Consider making reregisteredTime an Option.
+  if (framework.registeredTime != framework.reregisteredTime) {
+    object.values["reregistered_time"] = framework.reregisteredTime.secs();
+  }
+
+  // Model all of the tasks associated with a framework.
+  {
+    JSON::Array array;
+    foreachvalue (Task* task, framework.tasks) {
+      array.values.push_back(model(*task));
+    }
+
+    object.values["tasks"] = array;
+  }
+
+  // Model all of the completed tasks of a framework.
+  {
+    JSON::Array array;
+    foreach (const Task& task, framework.completedTasks) {
+      array.values.push_back(model(task));
+    }
+
+    object.values["completed_tasks"] = array;
+  }
+
+  // Model all of the offers associated with a framework.
+  {
+    JSON::Array array;
+    foreach (Offer* offer, framework.offers) {
+      array.values.push_back(model(*offer));
+    }
+
+    object.values["offers"] = array;
+  }
+
+  return object;
+}
+
+
+// Returns a JSON object modeled after a Slave.
+JSON::Object model(const Slave& slave)
+{
+  JSON::Object object;
+  object.values["id"] = slave.id.value();
+  object.values["pid"] = string(slave.pid);
+  object.values["hostname"] = slave.info.hostname();
+  object.values["registered_time"] = slave.registeredTime.secs();
+
+  if (slave.reregisteredTime.isSome()) {
+    object.values["reregistered_time"] = slave.reregisteredTime.get().secs();
+  }
+
+  object.values["resources"] = model(slave.info.resources());
+  object.values["attributes"] = model(slave.info.attributes());
+  return object;
+}
+
+// Returns a JSON object modeled after a Role.
+JSON::Object model(const Role& role)
+{
+  JSON::Object object;
+  object.values["name"] = role.info.name();
+  object.values["weight"] = role.info.weight();
+  object.values["resources"] = model(role.resources());
+
+  {
+    JSON::Array array;
+
+    foreachkey (const FrameworkID& frameworkId, role.frameworks) {
+      array.values.push_back(frameworkId.value());
+    }
+
+    object.values["frameworks"] = array;
+  }
+
+  return object;
+}
+
+
+const string Master::Http::HEALTH_HELP = HELP(
+    TLDR(
+        "Health check of the Master."),
+    USAGE(
+        "/master/health"),
+    DESCRIPTION(
+        "Returns 200 OK iff the Master is healthy.",
+        "Delayed responses are also indicative of poor health."));
+
+
+Future<Response> Master::Http::health(const Request& request)
+{
+  return OK();
+}
+
+
+const string Master::Http::REDIRECT_HELP = HELP(
+    TLDR(
+        "Redirects to the leading Master."),
+    USAGE(
+        "/master/redirect"),
+    DESCRIPTION(
+        "This returns a 307 Temporary Redirect to the leading Master.",
+        "If no Master is leading (according to this Master), then the",
+        "Master will redirect to itself.",
+        "",
+        "**NOTES:**",
+        "1. This is the recommended way to bookmark the WebUI when",
+        "running multiple Masters.",
+        "2. This is broken currently \"on the cloud\" (e.g. EC2) as",
+        "this will attempt to redirect to the private IP address."));
+
+
+
+Future<Response> Master::Http::redirect(const Request& request)
+{
+  LOG(INFO) << "HTTP request for '" << request.path << "'";
+
+  // If there's no leader, redirect to this master's base url.
+  UPID pid = master.leader.isSome() ? master.leader.get() : master.self();
+
+  Try<string> hostname = net::getHostname(pid.ip);
+  if (hostname.isError()) {
+    return InternalServerError(hostname.error());
+  }
+
+  return TemporaryRedirect(
+      "http://" + hostname.get() + ":" + stringify(pid.port));
+}
+
+
+Future<Response> Master::Http::stats(const Request& request)
+{
+  LOG(INFO) << "HTTP request for '" << request.path << "'";
+
+  JSON::Object object;
+  object.values["uptime"] = (Clock::now() - master.startTime).secs();
+  object.values["elected"] = master.elected(); // Note: using int not bool.
+  object.values["total_schedulers"] = master.frameworks.size();
+  object.values["active_schedulers"] = master.getActiveFrameworks().size();
+  object.values["activated_slaves"] = master.slaves.size();
+  object.values["deactivated_slaves"] = master.deactivatedSlaves.size();
+  object.values["staged_tasks"] = master.stats.tasks[TASK_STAGING];
+  object.values["started_tasks"] = master.stats.tasks[TASK_STARTING];
+  object.values["finished_tasks"] = master.stats.tasks[TASK_FINISHED];
+  object.values["killed_tasks"] = master.stats.tasks[TASK_KILLED];
+  object.values["failed_tasks"] = master.stats.tasks[TASK_FAILED];
+  object.values["lost_tasks"] = master.stats.tasks[TASK_LOST];
+  object.values["valid_status_updates"] = master.stats.validStatusUpdates;
+  object.values["invalid_status_updates"] = master.stats.invalidStatusUpdates;
+  object.values["outstanding_offers"] = master.offers.size();
+
+  // Get total and used (note, not offered) resources in order to
+  // compute capacity of scalar resources.
+  Resources totalResources;
+  Resources usedResources;
+  foreachvalue (Slave* slave, master.slaves) {
+    // Instead of accumulating all types of resources (which is
+    // not necessary), we only accumulate scalar resources. This
+    // helps us bypass a performance problem caused by range
+    // additions (e.g. ports).
+    foreach (const Resource& resource, slave->info.resources()) {
+      if (resource.type() == Value::SCALAR) {
+        totalResources += resource;
+      }
+    }
+    foreach (const Resource& resource, slave->resourcesInUse) {
+      if (resource.type() == Value::SCALAR) {
+        usedResources += resource;
+      }
+    }
+  }
+
+  foreach (const Resource& resource, totalResources) {
+    CHECK(resource.has_scalar());
+    double total = resource.scalar().value();
+    object.values[resource.name() + "_total"] = total;
+    Option<Resource> option = usedResources.get(resource);
+    CHECK(!option.isSome() || option.get().has_scalar());
+    double used = option.isSome() ? option.get().scalar().value() : 0.0;
+    object.values[resource.name() + "_used"] = used;
+    double percent = used / total;
+    object.values[resource.name() + "_percent"] = percent;
+  }
+
+  return OK(object, request.query.get("jsonp"));
+}
+
+
+Future<Response> Master::Http::state(const Request& request)
+{
+  LOG(INFO) << "HTTP request for '" << request.path << "'";
+
+  JSON::Object object;
+  object.values["version"] = MESOS_VERSION;
+  object.values["build_date"] = build::DATE;
+  object.values["build_time"] = build::TIME;
+  object.values["build_user"] = build::USER;
+  object.values["start_time"] = master.startTime.secs();
+  object.values["id"] = master.info.id();
+  object.values["pid"] = string(master.self());
+  object.values["activated_slaves"] = master.slaves.size();
+  object.values["deactivated_slaves"] = master.deactivatedSlaves.size();
+  object.values["staged_tasks"] = master.stats.tasks[TASK_STAGING];
+  object.values["started_tasks"] = master.stats.tasks[TASK_STARTING];
+  object.values["finished_tasks"] = master.stats.tasks[TASK_FINISHED];
+  object.values["killed_tasks"] = master.stats.tasks[TASK_KILLED];
+  object.values["failed_tasks"] = master.stats.tasks[TASK_FAILED];
+  object.values["lost_tasks"] = master.stats.tasks[TASK_LOST];
+
+  if (master.flags.cluster.isSome()) {
+    object.values["cluster"] = master.flags.cluster.get();
+  }
+
+  if (master.leader.isSome()) {
+    object.values["leader"] = string(master.leader.get());
+  }
+
+  if (master.flags.log_dir.isSome()) {
+    object.values["log_dir"] = master.flags.log_dir.get();
+  }
+
+  // Model all of the slaves.
+  {
+    JSON::Array array;
+    foreachvalue (Slave* slave, master.slaves) {
+      array.values.push_back(model(*slave));
+    }
+
+    object.values["slaves"] = array;
+  }
+
+  // Model all of the frameworks.
+  {
+    JSON::Array array;
+    foreachvalue (Framework* framework, master.frameworks) {
+      array.values.push_back(model(*framework));
+    }
+
+    object.values["frameworks"] = array;
+  }
+
+  // Model all of the completed frameworks.
+  {
+    JSON::Array array;
+
+    foreach (const std::tr1::shared_ptr<Framework>& framework,
+             master.completedFrameworks) {
+      array.values.push_back(model(*framework));
+    }
+
+    object.values["completed_frameworks"] = array;
+  }
+
+  return OK(object, request.query.get("jsonp"));
+}
+
+
+Future<Response> Master::Http::roles(const Request& request)
+{
+  LOG(INFO) << "HTTP request for '" << request.path << "'";
+
+  JSON::Object object;
+
+  // Model all of the roles.
+  {
+    JSON::Array array;
+    foreachvalue (Role* role, master.roles) {
+      array.values.push_back(model(*role));
+    }
+
+    object.values["roles"] = array;
+  }
+
+  return OK(object, request.query.get("jsonp"));
+}
+
+} // namespace master {
+} // namespace internal {
+} // namespace mesos {
diff --git a/src/python/setup.py.in b/src/python/setup.py.in
index 77fa880..8d17fc1 100644
--- a/src/python/setup.py.in
+++ b/src/python/setup.py.in
@@ -19,21 +19,6 @@ abs_top_builddir = '@abs_top_builddir@'
 src_python_dist = os.path.join('src', 'python', 'dist')
 src_python_native = os.path.join('src', 'python', 'native')
 
-leveldb = os.path.join('3rdparty', 'leveldb')
-zookeeper = os.path.join('3rdparty', 'zookeeper-3.3.4', 'src', 'c')
-libprocess = os.path.join('3rdparty', 'libprocess')
-
-# Even though a statically compiled libprocess should include glog,
-# libev, gperftools, and protobuf before installation this isn't the
-# case, so while a libtool managed build will correctly pull in these
-# libraries when building the final result, we need to explicitly
-# include them here (or more precisely, down where we actually include
-# libev.a and libprofiler.a).
-glog = os.path.join(libprocess, '3rdparty', 'glog-0.3.3')
-libev = os.path.join(libprocess, '3rdparty', 'libev-4.15')
-gperftools = os.path.join(libprocess, '3rdparty', 'gperftools-2.0')
-protobuf = os.path.join(libprocess, '3rdparty', 'protobuf-2.4.1')
-
 # We need to execute from the same directory as this script.
 os.chdir(os.path.abspath(os.path.dirname(__file__)))
 
@@ -63,26 +48,25 @@ INCLUDE_DIRS = [
    os.path.join(abs_top_srcdir, 'include'),
    os.path.join(abs_top_builddir, 'include'),
    os.path.join(abs_top_builddir, 'src'),
-   os.path.join(abs_top_builddir, src_python_native),
-   os.path.join(abs_top_builddir, protobuf, 'src'),
+   os.path.join(abs_top_builddir, src_python_native)
 ]
 
 LIBRARY_DIRS = []
 
+# TSTCLAIR: I still debate if this is unkosher.
+
 EXTRA_OBJECTS = [
   os.path.join(abs_top_builddir, 'src', '.libs', 'libmesos_no_3rdparty.a'),
-  os.path.join(abs_top_builddir, protobuf, 'src', '.libs', 'libprotobuf.a'),
-  os.path.join(abs_top_builddir, leveldb, 'libleveldb.a'),
-  os.path.join(abs_top_builddir, zookeeper, '.libs', 'libzookeeper_mt.a'),
-  os.path.join(abs_top_builddir, libprocess, '.libs', 'libprocess.a'),
-  os.path.join(abs_top_builddir, glog, '.libs', 'libglog.a'),
-  os.path.join(abs_top_builddir, libev, '.libs', 'libev.a'),
+  '-lprotobuf',
+  '-lleveldb',
+  '-lzookeeper_mt',
+  '-lglog',
+  '-lev',
 ]
 
 # For gperftools, we need to check for the presence of libprofiler.a, since
 # it is possible to disable perftools inside libprocess.
-libprofiler = os.path.join(
-    abs_top_builddir, gperftools, '.libs', 'libprofiler.a')
+libprofiler = '-lprofiler'
 
 if os.path.exists(libprofiler):
   EXTRA_OBJECTS.append(libprofiler)
diff --git a/src/zookeeper/authentication.hpp b/src/zookeeper/authentication.hpp
index 7b6b767..4adbccf 100644
--- a/src/zookeeper/authentication.hpp
+++ b/src/zookeeper/authentication.hpp
@@ -1,7 +1,7 @@
 #ifndef __ZOOKEEPER_AUTHENTICATION_HPP__
 #define __ZOOKEEPER_AUTHENTICATION_HPP__
 
-#include <zookeeper.h>
+#include <zookeeper/zookeeper.h>
 
 #include <string>
 
diff --git a/src/zookeeper/zookeeper.hpp b/src/zookeeper/zookeeper.hpp
index 7243543..26accb4 100644
--- a/src/zookeeper/zookeeper.hpp
+++ b/src/zookeeper/zookeeper.hpp
@@ -26,7 +26,7 @@
 #ifndef ZOOKEEPER_HPP
 #define ZOOKEEPER_HPP
 
-#include <zookeeper.h>
+#include <zookeeper/zookeeper.h>
 
 #include <string>
 #include <vector>
